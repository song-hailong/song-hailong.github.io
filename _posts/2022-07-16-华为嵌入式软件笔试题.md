---
layout: post
title: "华为嵌入式软件笔试题收集"
date: 2022-07-16
tag: 笔试题
---


> 本文为收集网站和论坛上的华为嵌入式软件笔试题

## 1、指针

```c++
int main(){ 
    inta[5]={1,2,3,4,5};   
    int *ptr=(int*)(&a+1); //a指向int类型，&a指向数组类型
    printf("%d,%d",*(a+1),*(ptr-1));
}
```

输出 2，5

## 2、死锁

产生死锁的**必要条件**：  
　　1）互斥条件（资源一次只允许一个进程访问）；  
　　2）不可剥夺条件（进程使用资源未完成之前，不能强行夺走）  
　　3）请求和保持条件（一个进程已经占有一个资源，还想获取另一个资源）；  
　　4）循环等待条件。

产生死锁的**原因**：资源竞争，进程推进顺序错误。

死锁的**处理**：  
　　预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。  
　　避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。  
　　检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。  
　　解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来。

## 3、main函数的返回值

C标准要求定义 int main()；  默认缺省也是int 。返回值一般用来指示程序运行是否正确。

## 4、地址操作

要对绝对地址0x100000赋值，我们可以用 (unsigned int*)0x100000 =1234; 那么要是想让程序跳转到绝对地址是0x100000去执行，应该怎么做？

答：`((void (*)())0x100000)();`
## 5、取反与补码

```c++
unsigned short A = 10;  // 32位
printf("~A = %u\n", ~A);  // 按位取反
char c = 128; // 字符类型表示范围：-128~127
              // 128的补码为 1000 0000，即值为 -128
printf("c=%d\n",c); 
```


输出  4294967285   和    -128。

 

## 6、用两个栈实现一个队列



## 7、宏定义函数

```c++
#define SQ(a) (a)*(a)
int main(){
	int a = 5;
	int b = SQ(a++); // 相当于 int b = (a++)*(a++)
	printf("%d %d",b,a);
}
```

输出：25 7  或  30  7   ，与编译器有关。



> 版权声明：本文为CSDN博主「嵌入式软件和硬件」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_38812277/article/details/90679215